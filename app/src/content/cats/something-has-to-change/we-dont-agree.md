# We just don't agree on this

No problem; every disagreement is a chance for us to get better at collaboration & making good choices (sometimes: good bets).

It's worth carefully steering intense disputes back to a shared discussion that's weighing importance, alternate paths, ease of changing course again, etc..

Pause if it feels personal, if someone will lose face if they back down.

## Is this about the dev, and how they work?

Well, they're the expert on them.

If they want to work in a way that (I think) isn't the best, but they're still not harming the team & meeting reqs for their role: okay.

## About the team & shared process?

We have to choose together; it's important that the people who say their ideas the loudest don't just win out.

It's also important that a team lead or manager's opinion doesn't just override others' — let's just make sure we're structuring decisions well, and run options together as experiments.

Feed input from 1-on-1s back into team discussions (giving credit!); and most people will "disagree & commit" to experiments where it's clear that we'll change course if it's not working as hoped.

> Let's also weigh how this feels — if we have a process that works but it makes some of us miserable, that's still no good.

## Technical path decisions

> Let's look long-term: whatever we do, assume it has to be maintained by someone who hasn't even joined the team yet.
>
> Will this be easy to explain? Or will they have to learn something custom & unusual? How will they debug if something breaks in here?

## Always follow-up

"Disagree and commit" only works when everyone involves **trusts** that the follow-up will really happen.

That trust is easy to kill; experiments must be real, and we must change course if an experiment doesn't work.

> Okay, let's go with this to start with, for the reasons listed, but:
>
> - This is a 2-week proof of concept spike only
> - We expect to be able to do X and Y in under a second by the end of it...
> - If we don't get there, or if we find other hard blockers early on, we drop this fast
> - If we DO get there, we won't use the PoC code itself; we'll then build it properly with tests etc.
>
> Our fallback is still building a custom extension for Z, and then maintaining it long-term; let's see!
>
> Anything we've forgotten?

These are promises, and if we don't keep them strictly (or get to consensus on why our original criteria were off), this approach will be **far** harder next time.
